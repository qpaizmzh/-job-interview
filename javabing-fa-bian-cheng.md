# 线程安全性

* 原子性--要么所有执行 要么所有都不执行，并且同一个时刻只有一个线程进行执行

* 可见性-- 修改了任何变量的值，其他线程都可以及时的观察到

* 有序性--一个线程观察其他线程中的指令的执行顺序，由于指令的重排序（CPU）造成，该观察结果一般都是无序

### 原子性-锁（synchronized）

* 类似于++variable这种的代码（假设variable变量是可见volatile），表面上看是只有一个操作，实际上它包含了三个：读取，修改，写回，结果的状态还会依赖之前的结果，这个是非原子性的

* 基于一种可能失效的观察结果来做出判断或者执行某个计算，这种类型的竞态条件叫做“先检查后执行”，说人话就是你执行之前查到的结果有可能是无效的

* 在JUC的包上，包含了一些基本类型的但是保证原子性的类，比如AtomicLong等

* ![](file://C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20191026114258600.png?lastModify=1572541199 "image-20191026114258600")

### 可见性

* JMM关于synchronized的规定

  * 线程解锁前，必须将工作内存中的工作变量最新值刷新到主内存

  * 线程加锁前，必须将自己本身的工作内存的值清空然后重新到主内存读取数值

### 有序性

* CPU在执行的过程中有可能会根据自己的优化策略来重新编排指令的执行顺序，这种情况在单线程程序中运行可能没有什么影响，但是在多线程的程序中结果就有可能会出错，这就要借助volitale atmoic类 锁的等工具类来保证程序的正确运行

* volitale变量有序性规则（happens-before）:对一个变量的写操作先行发生于后面对这个变量的操作

* 传递规则（happens-before）:A先行发生于B，B先行发生于C，则A先行发生于C



