# Spring事务的相关考点

* ACID
  * atomic原子性：要么一起完成，要么都不完成
  * consistency一致性：一旦事务完成，要确保它建模所处的业务要一致，不是部分完成部分失败
  * Isolation：隔离性多个事务彼此独立进行，互不干扰
  * Durability：持久性。一旦事务完成，状态被永久修改，不会因系统错误就回退事务，结果会被永久写到存储器
* 隔离级别
  * 读未提交：允许读被人数据修改但是还没有提交事务的数据，会出现脏读，不可重复读，幻读
  * 读已提交：只读取别人提交事务的数据，但是会出现不可重复读，幻读
  * 可重复读（默认隔离级别）：读已经提交的，读一些可以重复读的数据（就是上一次读的数据和后一次读取的一致），但是会出现幻读
  * 序列化：最高级别，不会出现读取上一次数据的数目比后一次数据的数目出现差异（就是幻读）
* 事务传播

  * 概念就是A事务方法调用B事务方法时，这个事务规则会怎么运行的一个行为
  * 一共七种：

    * PROPAGATION\_REQUIRED：如果A方法本身有事务，A调用B时，B也会加入A的事务中
    * Propagation\_SUPPORTS:如果A方法本身有事务，B则加入该事务，如果A没有事务，则B按照非事务执行

    * PROPAGATION\_MANDATORY:如果A方法是的事务状态是REQUIRED，B是MANDATORY，A调用B的时候，B进入A的事务中，B单独调用机会抛异常

    * PROPAGATION\_REQUIRES\_NEW：A包含事务B也包含事务的情况下，A调用B的时候，A的事务会被挂起，等待B的事务完成之后，再执行A的事务，这个需要JtaTransactionManager作为事务的管理器,所以即使A方法失败了，B也有可能执行成功

    * PROPAGATION\_NOT\_SUPPORTED：总是非事务执行，如果A有事务，B无事务，A调用B的时候，A的事务会被挂起，执行B的时候按照非事务执行，执行完成之后再执行A，同样要用到JtaTransactionManager

    * PROPAGATION\_NEVER：总是非事务执行，如果有事务，立即抛异常

    * PROPAGATION\_NESTED：如果B方法被标记了这个，A也有事务的时候，A应该在方法中设置一个savepoint方法，保存B的回滚点，如果外层事务失效回滚，也会包括B方法回滚，但是是B事务失败，A事务是不会回滚的



